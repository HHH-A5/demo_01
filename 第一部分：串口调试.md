## 串口.c.h文件

### 添加一个宏定义

![image-20251215112101438](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215112101438.png)

### 在HW文件夹下新建usart.c和usart.h，对于到include和source中

![image-20251215112636867](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215112636867.png)

添加如下代码

在usart.c中：

```c
#include "gd32f10x.h"
#include "usart.h"

uint8_t U0_RcBuff[U0_RX_SIZE];  // 接受数组
```

在usart.h中：

```c
#ifndef USART_H
#define USART_H

#include "stdint.h"

#define U0_RX_SIZE 2048
#define U0_RX_MAX 256
#define NUM 10

typedef struct{
	uint8_t *start;
	uint8_t *end;
}UCB_URxBuffptr;
// U:串口， CB:control block控制块

typedef struct{
	uint16_t URxCounter;
	UCB_URxBuffptr URxDataPtr[NUM];
	UCB_URxBuffptr *URxDataIN;
    UCB_URxBuffptr *URxDataOUT;
	UCB_URxBuffptr *URxDataEND;
	
}UCB_CB;
// 串口总的控制块

#endif

```

## 串口初始化函数

添加新文件库中的usart.c，同时在RTE定义一个打开串口的宏

![image-20251215155146676](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215155146676.png)

![image-20251215155414142](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215155414142.png)

同时在usart,c中编写初始化函数

```c
// 参数是波特率
void Usart0_Init(uint32_t bandrate)
{
	// 开时钟
	rcu_periph_clock_enable(RCU_USART0);
	rcu_periph_clock_enable(RCU_GPIOA);
	
	gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_9);
	gpio_init(GPIOA,GPIO_MODE_IN_FLOATING,GPIO_OSPEED_50MHZ,GPIO_PIN_10);
	
	usart_deinit(USART0);	                           //复位
	usart_baudrate_set(USART0,bandrate);  	         //波特率
	usart_parity_config(USART0,USART_PM_NONE);	     //校验方式
	usart_word_length_set(USART0,USART_WL_8BIT); 	 //数据位
	usart_stop_bit_set(USART0,USART_STB_1BIT); 	     //停止位
	usart_transmit_config(USART0,USART_TRANSMIT_ENABLE);	// 使能接收
	usart_receive_config(USART0,USART_RECEIVE_ENABLE);    // 使能发送
	
	usart_dma_receive_config(USART0,USART_RECEIVE_DMA_ENABLE);  // 使能DMA接受
	
	nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);           // 中断分组，比如两位是抢占，两位是优先
	nvic_irq_enable(USART0_IRQn,0,0);
	usart_interrupt_enable(USART0,USART_INT_IDLE);              // 使能空闲中断
	
	usart_enable(USART0);     // 总开关
}
```



## DMA初始化函数

添加新文件库中的dma.c，同时在RTE定义一个打开串口的宏

![image-20251215161918185](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215161918185.png)



在用户手册找串口接受的通道号,和数据寄存器地址

![image-20251215163104345](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215163104345.png)

![image-20251215165120894](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215165120894.png)

```c
void DMA_Init(void)
{
	dma_parameter_struct dma_init_struct;
	
	rcu_periph_clock_enable(RCU_DMA0);
	dma_deinit(DMA0,DMA_CH4);
	
  dma_init_struct.periph_addr = USART0+4;   //   USART0是寄地址，通过用户手册得知数据寄存器的偏移是0x04
	dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
	dma_init_struct.memory_addr = U0_RcBuff; 
	dma_init_struct.memory_width = DMA_MEMORY_WIDTH_8BIT;
	dma_init_struct.number = U0_RX_MAX+1;
	dma_init_struct.priority = DMA_PRIORITY_HIGH;
	dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
	dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
	dma_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;
	
	dma_init(DMA0,DMA_CH4,&dma_init_struct);
	
	dma_circulation_disable(DMA0,DMA_CH4);
	
	dma_channel_enable(DMA0,DMA_CH4);
}
```

## 配置空闲中断

在usart.c中添加，初始化结构体参数

```c

void U0Rx_PtrInit(void)
{
	U0CB.URxDataIN = &U0CB.URxDataPtr[0];
	U0CB.URxDataOUT = &U0CB.URxDataPtr[0];
	U0CB.URxDataEND = &U0CB.URxDataPtr[NUM - 1];
	U0CB.URxDataIN->start = U0_RcBuff;
	U0CB.URxCounter = 0;
}
```

在启动文件找到中断号

![image-20251215171339817](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215171339817.png)

回来gd32f10x_it.c编写函数，函数名就是中断号

![image-20251215171718747](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215171718747.png)

进入中断先判断是否为空闲中断，然后改清除标志位，用这种方法

![image-20251215172159204](C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20251215172159204.png)

```c
void USART0_IRQHandler(void)
{
	if(usart_interrupt_flag_get(USART0,USART_INT_FLAG_IDLE) != 0)
	{
		// 执行这两行代码，消除标志位
		usart_flag_get(USART0,USART_FLAG_IDLEF);
		usart_data_receive(USART0);
		U0CB.URxCounter += (U0_RX_MAX + 1) - dma_transfer_number_get(DMA0,DMA_CH4);   // get获取的是空的座位 ,总的座位U0_RX_MAX + 1
		U0CB.URxDataIN->end = &U0_RcBuff[U0CB.URxCounter - 1];
		U0CB.URxDataIN++;
		if(U0CB.URxDataIN == U0CB.URxDataEND)
		{
			U0CB.URxDataIN = &U0CB.URxDataPtr[0];
		}
		if(U0_RX_SIZE - U0CB.URxCounter >= U0_RX_MAX)
		{
			U0CB.URxDataIN->start = &U0_RcBuff[U0CB.URxCounter];   // 下一次存放数据的起始下标
			
		}
		else
		{
			
			// 又从头开始
			U0CB.URxDataIN->start = &U0_RcBuff[0]; 
			U0CB.URxCounter = 0;
		}
		
		// 重新配置，准备下一次数据的接收
		dma_channel_disable(DMA0,DMA_CH4);
		dma_transfer_number_config(DMA0,DMA_CH4,U0_RX_MAX + 1);
		dma_memory_address_config(DMA0,DMA_CH4,(uint32_t)U0CB.URxDataIN->start );
		dma_channel_enable(DMA0,DMA_CH4);
	}
	
}
```

这段代码实现了一个 **“USART0 + DMA 环形缓冲接收管理器”**，核心思想是：

> 让 DMA 一直把串口收到的数据搬到一个**大环形缓冲区** `U0_RcBuff[2048]` 里；  
> 每当一帧结束（IDLE 中断），就把**本次收到的数据块**登记到一个**指针队列** `U0CB.URxDataPtr[]` 中，供主程序以后消费；  
> 登记完后立即把 DMA 重新指向**下一个空闲块**，继续接收，永不阻塞。

------------------------------------------------
1 物理资源布局

```
USART0_RX ──► DMA0_CH4 ──► U0_RcBuff[2048]   (物理环形缓冲)
```

软件再把它切成 **逻辑块**（每块 ≤256 B），用结构体队列管理：

```
typedef struct {
    uint8_t *start;   // 本块首地址
    uint8_t *end;     // 本块末地址
} UCB_URxBuffptr;
```

------------------------------------------------
2 关键全局变量

```
U0_RcBuff[2048]        // 原始环形缓冲区
U0CB.URxCounter        // 已写指针（绝对下标，0~2047）
U0CB.URxDataPtr[10]    // 块描述符池（最多挂 10 个块）
U0CB.URxDataIN         // 当前“待填充”描述符
U0CB.URxDataOUT        // 当前“待读取”描述符（主程序用）
U0CB.URxDataEND        // 描述符池末地址（=&URxDataPtr[10]）
```

------------------------------------------------
3 中断执行流程（USART0_IRQHandler）

1. 清 IDLE 标志  
   读 `USART_FLAG_IDLEF` + 读 `USART_DATA` 是 GD32 清 IDLE 的唯一办法。

2. 计算本次收到多少字节  
   ```
   剩余座位 = dma_transfer_number_get(DMA0,CH4);   // DMA 还没搬的数量
   已收到   = (U0_RX_MAX+1) - 剩余座位;
   ```
   把结果累加到 `URxCounter`（绝对下标）。

3. 填写当前描述符  
   ```
   URxDataIN->end = &U0_RcBuff[URxCounter-1];
   URxDataIN++;                 // 准备下一次
   if 到达池尾则回卷到 0
   ```

4. 检查环形缓冲是否即将溢出  
   ```
   if (U0_RX_SIZE - URxCounter >= U0_RX_MAX)
       还有连续空间，下一帧继续往后放；
   else
       回卷到头部，URxCounter 归零；
   ```

5. 立即重设 DMA  
   ```
   关闭 DMA → 重设长度 257 → 重设内存地址 → 重新使能
   ```
   这样下一帧数据会无缝写到新块，**不会丢字节**。

------------------------------------------------
4 主程序如何消费数据

```
while (U0CB.URxDataOUT != U0CB.URxDataIN) {
    uint8_t *pStart = U0CB.URxDataOUT->start;
    uint8_t *pEnd   = U0CB.URxDataOUT->end;
    uint16_t len    = pEnd - pStart + 1;

    process_packet(pStart, len);

    U0CB.URxDataOUT++;
    if (U0CB.URxDataOUT == U0CB.URxDataEND)
        U0CB.URxDataOUT = &U0CB.URxDataPtr[0];
}
```
------------------------------------------------
## printf函数重写

```c
void u0_printf(char *format,...)
{
	uint16_t i;
	va_list listdata;
	va_start(listdata, format);
	vsprintf((char *)U0_TxBuff,format,listdata);   // #include "stdio.h"
	va_end(listdata);
	
	for(i = 0; i < strlen((const char *)U0_TxBuff); i++)
	{
		while(usart_flag_get(USART0,USART_FLAG_TBE) != 1);
		usart_data_transmit(USART0,U0_TxBuff[i]);
	}
	while(usart_flag_get(USART0,USART_FLAG_TBE) != 1);
}

```

其中还有一些extern,函数头文件声明就不具体细说了

同时在main.c里面测试

```
#include "gd32f10x.h"
#include "usart.h"

int main(void)
{
	Usart0_Init(921600);
	u0_printf("%d %c %x",0x30,0x30,0x30);
	
}
```

## 串口测试函数

```
int main(void)
{
	Usart0_Init(921600);
	u0_printf("%d %c %x\r\n",0x30,0x30,0x30);
	
	while(1)
	{
		if(U0CB.URxDataOUT != U0CB.URxDataIN)
		{
			u0_printf("this time get %d data\r\n",U0CB.URxDataOUT->end - U0CB.URxDataOUT->start +1);
			for(i = 0; i < U0CB.URxDataOUT->end - U0CB.URxDataOUT->start +1; i++)
			{
				u0_printf("%c",U0CB.URxDataOUT->start[i]);
			}
			u0_printf("\r\n\n\r");
			
			U0CB.URxDataOUT++;
		  if(U0CB.URxDataOUT == U0CB.URxDataEND)
		  {
			  U0CB.URxDataOUT = &U0CB.URxDataPtr[0];
	  	}
			
		}
		
	}
	
}
```

